{"ast":null,"code":"export let VideoToFramesMethod = /*#__PURE__*/function (VideoToFramesMethod) {\n  VideoToFramesMethod[VideoToFramesMethod[\"fps\"] = 0] = \"fps\";\n  VideoToFramesMethod[VideoToFramesMethod[\"totalFrames\"] = 1] = \"totalFrames\";\n  return VideoToFramesMethod;\n}({});\nexport class VideoToFrames {\n  /**\n   * Extracts frames from the video and returns them as an array of imageData\n   * @param videoUrl url to the video file (html5 compatible format) eg: mp4\n   * @param amount number of frames per second or total number of frames that you want to extract\n   * @param type [fps, totalFrames] The method of extracting frames: Number of frames per second of video or the total number of frames acros the whole video duration. defaults to fps\n   */\n  static getFrames(videoUrl, amount, type = VideoToFramesMethod.fps) {\n    return new Promise((resolve, reject) => {\n      let frames = [];\n      let canvas = document.createElement(\"canvas\");\n      let context = canvas.getContext(\"2d\");\n      let duration;\n      let video = document.createElement(\"video\");\n      video.preload = \"auto\";\n      let that = this;\n      video.addEventListener(\"loadeddata\", async function () {\n        canvas.width = video.videoWidth;\n        canvas.height = video.videoHeight;\n        duration = video.duration;\n        let totalFrames = amount;\n        if (type === VideoToFramesMethod.fps) {\n          totalFrames = duration * amount;\n        }\n        for (let time = 0; time < duration; time += duration / totalFrames) {\n          frames.push(await that.getVideoFrame(video, context, canvas, time));\n        }\n        resolve(frames);\n      });\n      video.src = videoUrl;\n      video.load();\n    });\n  }\n  static getVideoFrame(video, context, canvas, time) {\n    return new Promise((resolve, reject) => {\n      let eventCallback = () => {\n        video.removeEventListener(\"seeked\", eventCallback);\n        this.storeFrame(video, context, canvas, resolve);\n      };\n      video.addEventListener(\"seeked\", eventCallback);\n      video.currentTime = time;\n    });\n  }\n  static storeFrame(video, context, canvas, resolve) {\n    context.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);\n    resolve(canvas.toDataURL());\n  }\n}","map":{"version":3,"names":["VideoToFramesMethod","VideoToFrames","getFrames","videoUrl","amount","type","fps","Promise","resolve","reject","frames","canvas","document","createElement","context","getContext","duration","video","preload","that","addEventListener","width","videoWidth","height","videoHeight","totalFrames","time","push","getVideoFrame","src","load","eventCallback","removeEventListener","storeFrame","currentTime","drawImage","toDataURL"],"sources":["/Users/Macbook/Documents/video-trimmer-git/src/components/VideoToFrame.ts"],"sourcesContent":["export enum VideoToFramesMethod {\n    fps,\n    totalFrames\n  }\n  \n  export class VideoToFrames {\n    /**\n     * Extracts frames from the video and returns them as an array of imageData\n     * @param videoUrl url to the video file (html5 compatible format) eg: mp4\n     * @param amount number of frames per second or total number of frames that you want to extract\n     * @param type [fps, totalFrames] The method of extracting frames: Number of frames per second of video or the total number of frames acros the whole video duration. defaults to fps\n     */\n    public static getFrames(\n      videoUrl: string,\n      amount: number,\n      type: VideoToFramesMethod = VideoToFramesMethod.fps\n    ): Promise<string[]> {\n      return new Promise(\n        (\n          resolve: (frames: string[]) => void,\n          reject: (error: string) => void\n        ) => {\n          let frames: string[] = [];\n          let canvas: HTMLCanvasElement = document.createElement(\"canvas\");\n          let context: CanvasRenderingContext2D = canvas.getContext(\"2d\");\n          let duration: number;\n  \n          let video = document.createElement(\"video\");\n          video.preload = \"auto\";\n          let that = this;\n          video.addEventListener(\"loadeddata\", async function () {\n            canvas.width = video.videoWidth;\n            canvas.height = video.videoHeight;\n            duration = video.duration;\n  \n            let totalFrames: number = amount;\n            if (type === VideoToFramesMethod.fps) {\n              totalFrames = duration * amount;\n            }\n            for (let time = 0; time < duration; time += duration / totalFrames) {\n              frames.push(await that.getVideoFrame(video, context, canvas, time));\n            }\n            resolve(frames);\n          });\n          video.src = videoUrl;\n          video.load();\n        }\n      );\n    }\n  \n    private static getVideoFrame(\n      video: HTMLVideoElement,\n      context: CanvasRenderingContext2D,\n      canvas: HTMLCanvasElement,\n      time: number\n    ): Promise<string> {\n      return new Promise(\n        (resolve: (frame: string) => void, reject: (error: string) => void) => {\n          let eventCallback = () => {\n            video.removeEventListener(\"seeked\", eventCallback);\n            this.storeFrame(video, context, canvas, resolve);\n          };\n          video.addEventListener(\"seeked\", eventCallback);\n          video.currentTime = time;\n        }\n      );\n    }\n  \n    private static storeFrame(\n      video: HTMLVideoElement,\n      context: CanvasRenderingContext2D,\n      canvas: HTMLCanvasElement,\n      resolve: (frame: string) => void\n    ) {\n      context.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);\n      resolve(canvas.toDataURL());\n    }\n  }\n  "],"mappings":"AAAA,WAAYA,mBAAmB,0BAAnBA,mBAAmB;EAAnBA,mBAAmB,CAAnBA,mBAAmB;EAAnBA,mBAAmB,CAAnBA,mBAAmB;EAAA,OAAnBA,mBAAmB;AAAA;AAK7B,OAAO,MAAMC,aAAa,CAAC;EACzB;AACJ;AACA;AACA;AACA;AACA;EACI,OAAcC,SAASA,CACrBC,QAAgB,EAChBC,MAAc,EACdC,IAAyB,GAAGL,mBAAmB,CAACM,GAAG,EAChC;IACnB,OAAO,IAAIC,OAAO,CAChB,CACEC,OAAmC,EACnCC,MAA+B,KAC5B;MACH,IAAIC,MAAgB,GAAG,EAAE;MACzB,IAAIC,MAAyB,GAAGC,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;MAChE,IAAIC,OAAiC,GAAGH,MAAM,CAACI,UAAU,CAAC,IAAI,CAAC;MAC/D,IAAIC,QAAgB;MAEpB,IAAIC,KAAK,GAAGL,QAAQ,CAACC,aAAa,CAAC,OAAO,CAAC;MAC3CI,KAAK,CAACC,OAAO,GAAG,MAAM;MACtB,IAAIC,IAAI,GAAG,IAAI;MACfF,KAAK,CAACG,gBAAgB,CAAC,YAAY,EAAE,kBAAkB;QACrDT,MAAM,CAACU,KAAK,GAAGJ,KAAK,CAACK,UAAU;QAC/BX,MAAM,CAACY,MAAM,GAAGN,KAAK,CAACO,WAAW;QACjCR,QAAQ,GAAGC,KAAK,CAACD,QAAQ;QAEzB,IAAIS,WAAmB,GAAGrB,MAAM;QAChC,IAAIC,IAAI,KAAKL,mBAAmB,CAACM,GAAG,EAAE;UACpCmB,WAAW,GAAGT,QAAQ,GAAGZ,MAAM;QACjC;QACA,KAAK,IAAIsB,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGV,QAAQ,EAAEU,IAAI,IAAIV,QAAQ,GAAGS,WAAW,EAAE;UAClEf,MAAM,CAACiB,IAAI,CAAC,MAAMR,IAAI,CAACS,aAAa,CAACX,KAAK,EAAEH,OAAO,EAAEH,MAAM,EAAEe,IAAI,CAAC,CAAC;QACrE;QACAlB,OAAO,CAACE,MAAM,CAAC;MACjB,CAAC,CAAC;MACFO,KAAK,CAACY,GAAG,GAAG1B,QAAQ;MACpBc,KAAK,CAACa,IAAI,CAAC,CAAC;IACd,CACF,CAAC;EACH;EAEA,OAAeF,aAAaA,CAC1BX,KAAuB,EACvBH,OAAiC,EACjCH,MAAyB,EACzBe,IAAY,EACK;IACjB,OAAO,IAAInB,OAAO,CAChB,CAACC,OAAgC,EAAEC,MAA+B,KAAK;MACrE,IAAIsB,aAAa,GAAGA,CAAA,KAAM;QACxBd,KAAK,CAACe,mBAAmB,CAAC,QAAQ,EAAED,aAAa,CAAC;QAClD,IAAI,CAACE,UAAU,CAAChB,KAAK,EAAEH,OAAO,EAAEH,MAAM,EAAEH,OAAO,CAAC;MAClD,CAAC;MACDS,KAAK,CAACG,gBAAgB,CAAC,QAAQ,EAAEW,aAAa,CAAC;MAC/Cd,KAAK,CAACiB,WAAW,GAAGR,IAAI;IAC1B,CACF,CAAC;EACH;EAEA,OAAeO,UAAUA,CACvBhB,KAAuB,EACvBH,OAAiC,EACjCH,MAAyB,EACzBH,OAAgC,EAChC;IACAM,OAAO,CAACqB,SAAS,CAAClB,KAAK,EAAE,CAAC,EAAE,CAAC,EAAEA,KAAK,CAACK,UAAU,EAAEL,KAAK,CAACO,WAAW,CAAC;IACnEhB,OAAO,CAACG,MAAM,CAACyB,SAAS,CAAC,CAAC,CAAC;EAC7B;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}